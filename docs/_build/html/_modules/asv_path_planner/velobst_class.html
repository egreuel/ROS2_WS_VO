<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>asv_path_planner.velobst_class &mdash; Velocity Obstacle 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Velocity Obstacle
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Results.html">Results</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asv_path_planner.html">Implementation in python</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Velocity Obstacle</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">asv_path_planner.velobst_class</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for asv_path_planner.velobst_class</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The velocity obstacle class is used to calculate the velocity obstacle for several TS and calculate the optimal velocity to avoid a collison.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Point</span>
<span class="kn">from</span> <span class="nn">geopy</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">mode</span>

<span class="c1"># input: vel_OS[speed(m/s), angle(° in NED frame)], len_OS[m], wid_OS[m], max_speed_OS [m/s], max_TTC[s], min_TTC[s], saftey_fact[],</span>
<span class="c1">#        speed_TS[m/s], speed_TS_unc[m/s], ang_TS[° in NED frame], ang_TS_unc[°], speed_res[m/s], ang_res[°], pos_TS_rel[x,y], len_TS[m], wid_TS[m]</span>

<span class="c1"># output: new absolute course</span>

<span class="c1"># Plotting</span>
<span class="c1"># plotting = False</span>
<div class="viewcode-block" id="VO"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO">[docs]</a><span class="k">class</span> <span class="nc">VO</span><span class="p">:</span>

    <span class="c1"># Weights for the cost-function to choose the new velocity</span>
    <span class="n">w_1</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Angle deviation from desired velocity</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Weight factor of the cost function to calculate the new velocity for the angle deviation from the desired velocity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w_2</span> <span class="o">=</span> <span class="mf">1.3</span>  <span class="c1"># Speed deviation from desried velocity</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Weight factor of the cost function to calculate the new velocity for the speed deviation from the desired velocity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w_3</span> <span class="o">=</span> <span class="mf">1.5</span>  <span class="c1"># Angle deviation from 30° to the inital velocity</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Weight factor of the cost function to calculate the new velocity for the 30°angle deviation from the initial velocity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leng_OS</span><span class="p">,</span> <span class="n">width_OS</span><span class="p">,</span> <span class="n">max_speedOS</span><span class="p">,</span> <span class="n">time_col</span><span class="p">,</span> <span class="n">treshhold</span><span class="p">,</span> <span class="n">safe_domain_fact</span><span class="p">,</span> <span class="n">speed_unc</span><span class="p">,</span> <span class="n">ang_unc</span><span class="p">,</span> <span class="n">speed_res</span><span class="p">,</span> <span class="n">ang_res</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to initalize parameters of the OS once it is assinged to the class</span>

<span class="sd">        Args:</span>
<span class="sd">            leng_OS (float [m/s]): Length of the OS</span>
<span class="sd">            width_OS (float [m/s]): Width of the OS</span>
<span class="sd">            max_speedOS (float [m/s]): maximum speed of the OS</span>
<span class="sd">            time_col (int [s]): Velocities leading to a collison where the time to collision isgreater than this time will not be considerd from the algorithm</span>
<span class="sd">            treshhold (int [s]): Time threshold to collision for stand-by scenarios; if the time to collision is smaller than this value, the OS is avoiding the collision even if it is the stand-by vessel</span>
<span class="sd">            safe_domain_fact (int): Factor for the safety domain --&gt; multiple of the OS size</span>
<span class="sd">            speed_unc (float [m/s]): Uncertainties in the speed measurements of the TS</span>
<span class="sd">            ang_unc (float [°]): Uncertainties in the orientation angle measurements of the TS</span>
<span class="sd">            speed_res (float [m/s]): Resolution of speed for the descitized velocity space</span>
<span class="sd">            ang_res (float [°]): Resolution of orientation angle for the descitized velocity space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colreg</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Variable needed to make sure, that in case of an overtaking, the OS is not changing the side on which to overtake during the manouver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Properties of OS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_OS</span> <span class="o">=</span> <span class="n">leng_OS</span>  <span class="c1"># Length OS in m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wid_OS</span> <span class="o">=</span> <span class="n">width_OS</span>  <span class="c1"># Width OS in m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_speed_OS</span> <span class="o">=</span> <span class="n">max_speedOS</span> <span class="c1"># Maximum speed of OS in m/s</span>

        <span class="c1"># Time thresholds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_TTC</span> <span class="o">=</span> <span class="n">time_col</span>  <span class="c1"># Time to collison in s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">treshhold</span>  <span class="c1"># time to collision threshold in s for standby actions</span>

        <span class="c1"># Safety area factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">safe_Fact</span> <span class="o">=</span> <span class="n">safe_domain_fact</span>
        
        <span class="c1"># Uncertainty handling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unc_speed</span> <span class="o">=</span> <span class="n">speed_unc</span>  <span class="c1"># m/s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unc_angle</span> <span class="o">=</span> <span class="n">ang_unc</span>  <span class="c1"># degrees</span>
        
        <span class="c1"># Resolution of the discretized velocity space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_speed</span> <span class="o">=</span> <span class="n">speed_res</span> <span class="c1"># m/s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_ang</span> <span class="o">=</span> <span class="n">ang_res</span> <span class="c1"># degrees</span>

        <span class="c1"># Variable to store the inital state of OS once a collision check is true</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Variable to store if the saftey domain is violated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_safety</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Variable to store the latest calculated new velocity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_new_vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<div class="viewcode-block" id="VO.calc_coord_gps_to_xy"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_coord_gps_to_xy">[docs]</a>    <span class="k">def</span> <span class="nf">calc_coord_gps_to_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord_os</span><span class="p">,</span> <span class="n">coord_ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to calculate GPS coordinates to xy-coordinates in meters in resepct to the OS;</span>
<span class="sd">        Returns the position of the target ship relative to the own ship in the xy-coordinate system</span>

<span class="sd">        Args:</span>
<span class="sd">            coord_os (numpy.array(float)): GPS coordiantes of OS (Latitude, longitude)</span>
<span class="sd">            coord_ts (numpy.array(float)): GPS coordiantes of TS (Latitude, longitude)</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): Relative position of TS to OS in xy-coordinates (x[m],y[m])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_TSy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coord_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord_os</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">pos_TSx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coord_os</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord_ts</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="c1"># Relative position and realtive velocity</span>
        <span class="c1"># Relative position:</span>
        <span class="n">pos_Rel_gps</span> <span class="o">=</span> <span class="n">coord_ts</span> <span class="o">-</span> <span class="n">coord_os</span>
        <span class="k">if</span> <span class="n">pos_Rel_gps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos_Rely</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">great_circle</span><span class="p">(</span><span class="n">pos_TSy</span><span class="p">,</span> <span class="n">coord_os</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_Rely</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">great_circle</span><span class="p">(</span><span class="n">pos_TSy</span><span class="p">,</span> <span class="n">coord_os</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos_Rel_gps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos_Relx</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">great_circle</span><span class="p">(</span><span class="n">pos_TSx</span><span class="p">,</span> <span class="n">coord_os</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_Relx</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">great_circle</span><span class="p">(</span><span class="n">pos_TSx</span><span class="p">,</span> <span class="n">coord_os</span><span class="p">)</span>
        <span class="n">pos_Rel</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_Relx</span><span class="o">.</span><span class="n">meters</span><span class="p">,</span> <span class="n">pos_Rely</span><span class="o">.</span><span class="n">meters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_Rel</span><span class="p">)</span></div>


<div class="viewcode-block" id="VO.calc_abs_vel"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_abs_vel">[docs]</a>    <span class="k">def</span> <span class="nf">calc_abs_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abs_vel_os</span><span class="p">,</span> <span class="n">rel_vel_ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to calculate the absolute velocity of the TS if only the</span>
<span class="sd">        relative velocity of TS to OS is given;</span>
<span class="sd">        Returns the absolute velocity of the target ship with speed and angle</span>

<span class="sd">        Args:</span>
<span class="sd">            abs_vel_os (numpy.array(float)): Absolute velocity vector of OS (speed[m/s], angle[°])</span>
<span class="sd">            rel_vel_ts (numpy.array(float)): Relative velocity vector of TS to OS (speed[m/s], angle[°])</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): Absolute velocity of the TS (speed[m/s], angle[°])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x and y componet of the vector from magnitude (speed) and direction (angle)</span>
        <span class="n">abs_vel_osxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">abs_vel_os</span><span class="p">)</span>
        <span class="n">vel_Relxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">rel_vel_ts</span><span class="p">)</span>
        <span class="c1"># Calculate the TS vector in component form</span>
        <span class="n">vel_TSxy_calc</span> <span class="o">=</span> <span class="n">vel_Relxy</span> <span class="o">+</span> <span class="n">abs_vel_osxy</span>
        <span class="c1"># Calculate the magnitude (speed) of the vector</span>
        <span class="n">speed_TS_calc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vel_TSxy_calc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">vel_TSxy_calc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Calculate the dircetion (angle) of the vector</span>
        <span class="n">ang_TS_calc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vel_TSxy_calc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vel_TSxy_calc</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ang_TS_calc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ang_TS_calc</span><span class="o">+</span><span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="c1"># convert the angle from east CCW to north CW</span>
        <span class="n">ang_TS_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ang_n_to_e</span><span class="p">(</span><span class="n">ang_TS_calc</span><span class="p">)</span>
        <span class="n">vel_TS_calc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">speed_TS_calc</span><span class="p">,</span> <span class="n">ang_TS_calc</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vel_TS_calc</span><span class="p">)</span></div>


<div class="viewcode-block" id="VO.calc_rel_vel"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_rel_vel">[docs]</a>    <span class="k">def</span> <span class="nf">calc_rel_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to calculate the relative velocity of the OS to TS if only the</span>
<span class="sd">        absolute velocity of TS and OS are given;</span>
<span class="sd">        Returns the relative velocity of the OS to TS with speed and angle</span>

<span class="sd">        Args:</span>
<span class="sd">            vel_OS (numpy.array(float)): Absolute velocity vector of OS (speed[m/s], angle[°])</span>
<span class="sd">            vel_TS (numpy.array(float)): Absolute velocity vector of TS (speed[m/s], angle[°])</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): Relative velocity of OS to TS (speed[m/s], angle[°])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x and y componet of the vector from magnitude (speed) and direction (angle)</span>
        <span class="n">vel_OSxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">)</span>
        <span class="n">vel_TSxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_TS</span><span class="p">)</span>
        <span class="c1"># Calculate the relative vector in component form</span>
        <span class="n">vel_Relxy</span> <span class="o">=</span> <span class="n">vel_OSxy</span> <span class="o">-</span> <span class="n">vel_TSxy</span>
        <span class="c1"># Calculate the magnitude (speed) of the vector</span>
        <span class="n">speed_Rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vel_Relxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">vel_Relxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Calculate the dircetion (angle) of the vector</span>
        <span class="n">ang_Rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vel_Relxy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vel_Relxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ang_Rel</span> <span class="o">=</span> <span class="p">(</span><span class="n">ang_Rel</span><span class="o">+</span><span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="c1"># convert the angle from east CCW to north CW</span>
        <span class="n">ang_Rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ang_n_to_e</span><span class="p">(</span><span class="n">ang_Rel</span><span class="p">)</span>
        <span class="n">vel_Rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">speed_Rel</span><span class="p">,</span> <span class="n">ang_Rel</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vel_Rel</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.vect_to_ang_mag"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.vect_to_ang_mag">[docs]</a>    <span class="k">def</span> <span class="nf">vect_to_ang_mag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vect_xy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function that calculates the magnitude (speed) and direction (angle) of a vector given</span>
<span class="sd">        in x/y-form </span>

<span class="sd">        Args:</span>
<span class="sd">            vect_xy (numpy.array(float)): Velocity vector in xy-form</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): Velocity vector in the form magnitude (speed) and direction (angle)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vect_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">vect_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vect_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vect_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle</span><span class="o">+</span><span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ang_n_to_e</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">([</span><span class="n">speed</span><span class="p">,</span> <span class="n">angle</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.vect_to_xy"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.vect_to_xy">[docs]</a>    <span class="k">def</span> <span class="nf">vect_to_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function that calculates the x/y-form of a vector given in</span>
<span class="sd">        magnitude/direction-form </span>

<span class="sd">        Args:</span>
<span class="sd">            vector (numpy.array(float)): Velocity vector in magnitude/direction-form</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): Velocity vector in the xy-form (x[m],y[m])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vect_xy</span> <span class="o">=</span> <span class="p">([</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_ang_n_to_e</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]))),</span>
                            <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_ang_n_to_e</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">])))])</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vect_xy</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.calc_ang_n_to_e"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_ang_n_to_e">[docs]</a>    <span class="k">def</span> <span class="nf">calc_ang_n_to_e</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function that converts the angle from the north clockwise system to the</span>
<span class="sd">        east counter-clockwise system and vice versa </span>

<span class="sd">        Args:</span>
<span class="sd">            angle (float): Orientation angle in north clockwise or east counter-clockwise system</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Orientation angle base on the other system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="k">return</span> <span class="n">alpha</span></div>

<div class="viewcode-block" id="VO.calc_minkowski_sum"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_minkowski_sum">[docs]</a>    <span class="k">def</span> <span class="nf">calc_minkowski_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert_TS</span><span class="p">,</span> <span class="n">vert_OS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to calculate the Minkowski sum of two shapes</span>

<span class="sd">        Args:</span>
<span class="sd">            vert_TS (numpy.array(float)): numpy array of xy-coordinates that form the shape of the TS</span>
<span class="sd">            vert_OS (numpy.array(float)): numpy array of xy-coordinates that form the shape of the OS</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): numpy array with new xy-coordinates of the added shapes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vert_TS</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">vert_OS</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.orientation"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.orientation">[docs]</a>    <span class="k">def</span> <span class="nf">orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculation of all points that are right or left of a directed vector</span>
<span class="sd">     </span>
<span class="sd">        Args:</span>
<span class="sd">            v1(numpy.array(float)): Point 1 of the directed vector</span>
<span class="sd">            v2(numpy.array(float)): Point 2 of the directed vector</span>
<span class="sd">            p(numpy.array(float)): Points that are tested</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float), numpy.array(float): all points left from the vector formed by v1, v2; all points right from the vector formed by v1, v2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span> \
            <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="n">v_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">v_in</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)):</span>
            
            <span class="c1"># check if inside</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">v_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check if outside</span>
                <span class="n">v_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_out</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_in</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="VO.inOutVO"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.inOutVO">[docs]</a>    <span class="k">def</span> <span class="nf">inOutVO</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_test</span><span class="p">,</span> <span class="n">vo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculation of all point inside or outside the velocity obstacle</span>

<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            v_test(numpy.array(float)): Velocity vector in xy-coordinates to test</span>
<span class="sd">            vo(numpy.array(float)): velocity obstacle vertices  </span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float), numpy.array(float): all points outside the VO; all points inside the VO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v_outn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vo</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v_test</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">v_out</span><span class="p">,</span> <span class="n">v_test</span>  <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">(</span><span class="n">vo</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">vo</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">v_test</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v_out</span><span class="p">):</span>
                <span class="n">v_outn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">v_outn</span><span class="p">,</span> <span class="n">v_out</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_outn</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_test</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.check_collision"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.check_collision">[docs]</a>    <span class="k">def</span> <span class="nf">check_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_p</span><span class="p">,</span> <span class="n">vel_obs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function that checks if a point is inside a convex shape</span>

<span class="sd">        Args:</span>
<span class="sd">            vel_p (numpy.array(float)): Point to be tested</span>
<span class="sd">            vel_obs (numpy.array(float)): Vertices of the shape to be tested against</span>

<span class="sd">        Returns:</span>
<span class="sd">            boolean: True if point is inside the shape, False if outside the shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vel_p_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_p</span><span class="p">)</span>
        <span class="n">vel_p_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vel_p_xy</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">outo</span><span class="p">,</span> <span class="n">intu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inOutVO</span><span class="p">(</span><span class="n">vel_p_xy</span><span class="p">,</span> <span class="n">vel_obs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">intu</span><span class="p">):</span>
            <span class="n">collision</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collision</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">collision</span></div>

<div class="viewcode-block" id="VO.calc_ang_vect"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_ang_vect">[docs]</a>    <span class="k">def</span> <span class="nf">calc_ang_vect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">,</span> <span class="n">vel_Rel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to calculate the angle that is formed by two velocity vectors</span>

<span class="sd">        Args:</span>
<span class="sd">            vel_OS (numpy.array(float)): Velocity vector (speed[m/s], angle[°])</span>
<span class="sd">            vel_Rel (numpy.array(float)): Velocity vector (speed[m/s], angle[°])</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Angle between two vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="p">((</span><span class="n">vel_Rel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="k">return</span> <span class="n">phi</span></div>

<div class="viewcode-block" id="VO.check_colreg_rule_heading"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.check_colreg_rule_heading">[docs]</a>    <span class="k">def</span> <span class="nf">check_colreg_rule_heading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_OS_2</span><span class="p">,</span> <span class="n">vel_TS_2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function that checks which COLREG rule have to be applied (angle between the course </span>
<span class="sd">        over gorud of OS and </span>

<span class="sd">        Args:</span>
<span class="sd">            vel_OS_2 (numpy.array(float)): Velocity vector of OS (speed[m/s], angle[°])</span>
<span class="sd">            vel_TS_2 (numpy.array(float)): elocity vector of TS (speed[m/s], angle[°])</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String of the COLREG rule applied for the given encounter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="n">vel_TS_2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vel_TS_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">180</span>
        <span class="k">if</span> <span class="n">vel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">:</span>  <span class="c1"># Threshhold for static objects</span>
            <span class="n">colreg_rule_2</span> <span class="o">=</span> <span class="s1">&#39;Static object&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ang_vect</span><span class="p">(</span><span class="n">vel_OS_2</span><span class="p">,</span> <span class="n">vel</span><span class="p">)</span>
            <span class="k">if</span> <span class="mi">15</span> <span class="o">&lt;=</span> <span class="n">phi_2</span> <span class="o">&lt;=</span> <span class="mf">112.5</span><span class="p">:</span>
                <span class="n">colreg_rule_2</span> <span class="o">=</span> <span class="s1">&#39;Right crossing (Rule 15)&#39;</span>
            <span class="k">elif</span> <span class="mf">112.5</span> <span class="o">&lt;</span> <span class="n">phi_2</span> <span class="o">&lt;=</span> <span class="mf">247.5</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vel_OS_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">vel</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">colreg_rule_2</span> <span class="o">=</span> <span class="s1">&#39;Being Overtaken (Rule 13)&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">colreg_rule_2</span> <span class="o">=</span> <span class="s1">&#39;Overtaking (Rule 13)&#39;</span>
            <span class="k">elif</span> <span class="mf">247.5</span> <span class="o">&lt;</span> <span class="n">phi_2</span> <span class="o">&lt;=</span> <span class="mi">345</span><span class="p">:</span>
                <span class="n">colreg_rule_2</span> <span class="o">=</span> <span class="s1">&#39;Left crossing (Rule 15)&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">colreg_rule_2</span> <span class="o">=</span> <span class="s1">&#39;Head-on (Rule 14)&#39;</span>
        <span class="k">return</span> <span class="n">colreg_rule_2</span></div>

<div class="viewcode-block" id="VO.check_side"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.check_side">[docs]</a>    <span class="k">def</span> <span class="nf">check_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_Rel</span><span class="p">,</span> <span class="n">tang_coord</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function that checks wether the relative velocity of OS to TS is inside the CC or</span>
<span class="sd">        outside, if outside check which side</span>

<span class="sd">        Args:</span>
<span class="sd">            vel_Rel (numpy.array(float)): Relative velocity vector of OS to TS (speed, angle)</span>
<span class="sd">            tang_coord (numpy.array(float)): Coordinates of the tangent points of TS shape that form the CC</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String that say if the velocity is inside, right or left of the CC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;empty or inside&#39;</span>

        <span class="n">tang_points_vec_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_ang_mag</span><span class="p">(</span><span class="n">tang_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">tang_points_vec_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_ang_mag</span><span class="p">(</span><span class="n">tang_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">angles_betw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_betw_vect</span><span class="p">(</span><span class="n">vel_Rel</span><span class="p">,</span> <span class="n">tang_points_vec_1</span><span class="p">,</span> <span class="n">tang_points_vec_2</span><span class="p">)</span>
        <span class="n">angles_betw_tang</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_betw_vect</span><span class="p">(</span><span class="n">tang_points_vec_1</span><span class="p">,</span> <span class="n">tang_points_vec_2</span><span class="p">)</span>
      
        <span class="k">if</span> <span class="n">angles_betw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">angles_betw_tang</span><span class="p">:</span>
            <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
        <span class="k">elif</span> <span class="n">angles_betw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">angles_betw_tang</span><span class="p">:</span>
            <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>

        <span class="k">return</span> <span class="n">side</span></div>

<div class="viewcode-block" id="VO.ang_betw_vect"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.ang_betw_vect">[docs]</a>    <span class="k">def</span> <span class="nf">ang_betw_vect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_vect</span><span class="p">,</span> <span class="o">*</span><span class="n">test_vect</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to calculate the angle between two vectors in range 0 to 180°</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_vect (numpy.array(float)): Velocity vector to which the angle is calculated</span>
<span class="sd">            *test_vect (numpy.array(float)): Velocity vectors that are tested against the ref_vect</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): Angles [°] between the reference vector and the test vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_vect_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">ref_vect</span><span class="p">)</span>
        <span class="n">test_vect_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">test_vect</span><span class="p">)</span>
        <span class="n">test_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vect_to_ang_mag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">test_vect_xy</span><span class="p">)</span>
        <span class="n">in_arcos</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">test_vect_xy</span><span class="p">,</span> <span class="n">ref_vect_xy</span><span class="p">))</span> <span class="o">/</span> \
            <span class="p">(</span><span class="n">test_vect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ref_vect</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">in_arcos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">in_arcos</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">angles_betw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">in_arcos</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angles_betw</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="VO.angle_diff"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.angle_diff">[docs]</a>    <span class="k">def</span> <span class="nf">angle_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_angle</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function that calculates the difference of an orientation angle in respect to another from -180 to 180°</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_angle (float[°]): Reference angle to which the difference is calculated</span>
<span class="sd">            angle (float[°]): Deviating angle from the reference angle</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Angle difference in a range from -180 to 180°</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">-</span> <span class="n">ref_angle</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">-=</span> <span class="mi">360</span>
        <span class="k">elif</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">180</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">+=</span> <span class="mi">360</span>
        <span class="k">return</span> <span class="n">diff</span></div>

<div class="viewcode-block" id="VO.calc_vel_obst"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_vel_obst">[docs]</a>    <span class="k">def</span> <span class="nf">calc_vel_obst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">TS</span><span class="p">,</span> <span class="n">ang_os_rad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function that calculates the Velocity Obstacle of each TS with uncertainities and with respect to the time to collision</span>

<span class="sd">        Args:</span>
<span class="sd">            TS (class object): Object of the class TS with information about the target ship (see `Target Ship (TS) module`_)</span>
<span class="sd">            ang_os_rad (float): Orientation of the OS in radian</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float), numpy.array(float), numpy.array(float): vertices of the velocity obstacle; vertices of the saftey area around the TS; </span>
<span class="sd">            tangent points at the safety area around TS seen from OS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_TS_rel</span> <span class="o">=</span> <span class="n">TS</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">len_TS</span> <span class="o">=</span> <span class="n">TS</span><span class="o">.</span><span class="n">length</span>
        <span class="n">wid_TS</span> <span class="o">=</span> <span class="n">TS</span><span class="o">.</span><span class="n">width</span>
        <span class="n">speed_TS</span> <span class="o">=</span> <span class="n">TS</span><span class="o">.</span><span class="n">speed</span>
        <span class="n">ang_TS</span> <span class="o">=</span> <span class="n">TS</span><span class="o">.</span><span class="n">ang</span>
        <span class="n">vel_TS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">speed_TS</span><span class="p">,</span> <span class="n">ang_TS</span><span class="p">])</span>
        <span class="c1"># vel_Rel = calc_rel_vel(vel_OS, vel_TS)</span>
        <span class="c1"># vel_Relxy = self.vect_to_xy(vel_Rel) # (Just for plotting)</span>
        <span class="c1"># Geodesic Distance (ellipsoidal model of the earth) for GPS coordinates</span>
        <span class="c1"># dist_TSOS = distance.distance(pos_TS, pos_OS)</span>
        <span class="c1"># print(&#39;Distance =&#39;, dist_TSOS.meters, &#39;m&#39;)</span>

        <span class="c1"># Convert angle from degree to radians</span>
        <span class="n">ang_TS_rad</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ang_TS</span><span class="p">)</span>
        <span class="n">ang_OS_rad</span> <span class="o">=</span> <span class="n">ang_os_rad</span>
        <span class="c1"># Calculate the xy-form of the velocity vector</span>
        <span class="n">vel_TSxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_TS</span><span class="p">)</span>

        <span class="c1"># Calclate the relative position of the TS in meters</span>
        <span class="c1"># pos_TS_rel = calc_coord_gps_to_xy(pos_OS, pos_TS)</span>

        <span class="c1"># Calculate the vertices of the OS around it</span>
        <span class="n">vert_OS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">wid_OS</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_OS</span><span class="p">],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">wid_OS</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_OS</span><span class="p">],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">wid_OS</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_OS</span><span class="p">],</span>
                            <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">wid_OS</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">len_OS</span><span class="p">]])</span>

        <span class="c1"># Rotate the vertices in the direction the OS is facing</span>
        <span class="n">rot_M_OS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang_OS_rad</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang_OS_rad</span><span class="p">)],</span>
                            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang_OS_rad</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang_OS_rad</span><span class="p">)]])</span>
    
        <span class="n">vert_OS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vert_OS</span><span class="p">,</span><span class="n">rot_M_OS</span><span class="p">)</span>
        
        <span class="c1"># add safety factor for the OS</span>
        <span class="n">vert_OS_safe</span> <span class="o">=</span> <span class="n">vert_OS</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">safe_Fact</span>

        
        <span class="c1"># Calculate the vertices of the TS around it</span>
        <span class="n">vert_TS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">wid_TS</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">len_TS</span><span class="p">],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="n">wid_TS</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">len_TS</span><span class="p">],</span>
                            <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="n">wid_TS</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">len_TS</span><span class="p">],</span>
                            <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">wid_TS</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">len_TS</span><span class="p">]])</span>

        <span class="c1"># Rotate the vertices in the direction the TS is facing</span>
        <span class="n">rot_M_TS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang_TS_rad</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang_TS_rad</span><span class="p">)],</span>
                            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang_TS_rad</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang_TS_rad</span><span class="p">)]])</span>

        <span class="n">vert_TS</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vert_TS</span><span class="p">[:],</span> <span class="n">rot_M_TS</span><span class="p">)</span>
        
        <span class="c1"># Add the relative Position of the TS</span>
        <span class="n">vert_TS</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vert_TS</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_TS_rel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vert_TS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vert_TS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_TS_rel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">exp_vert_TS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># (Just for plotting)</span>
        <span class="n">exp_vert_TS_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">vert_hull</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Expand the shape of the TS with the shape of OS and OS*safty factor</span>
        <span class="n">exp_vert_TS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_minkowski_sum</span><span class="p">(</span><span class="n">vert_TS</span><span class="p">,</span> <span class="o">-</span><span class="n">vert_OS</span><span class="p">)</span>  <span class="c1"># (Just for plotting)</span>
        <span class="n">exp_vert_TS_safe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_minkowski_sum</span><span class="p">(</span><span class="n">vert_TS</span><span class="p">,</span> <span class="o">-</span><span class="n">vert_OS_safe</span><span class="p">)</span>

        <span class="c1"># # plot the vertices of the OS</span>
        <span class="c1"># plt.scatter(vert_OS[:,0], vert_OS[:,1], marker=&#39;.&#39;, linewidths=(0.1))</span>

        <span class="c1"># Convex Hull function of scipy library to create a hull of the new points of the minkowski sum</span>
        <span class="c1"># Expanded TS shape by OS (just for plotting)</span>
        <span class="n">hull_exp</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">exp_vert_TS</span><span class="p">)</span>
        <span class="n">hull_safe</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">exp_vert_TS_safe</span><span class="p">)</span>

        <span class="c1"># Plot the Polygons formed by the hull as filled polygons</span>
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="c1"># Plot the shape of OS</span>
            
            <span class="c1"># plt.fill(vert_OS[:, 0]+vert_TS[0, 0], vert_OS[:,1]+vert_TS[0, 1], &#39;blue&#39;, alpha=0.3, zorder=2, edgecolor=&#39;black&#39;)</span>
            <span class="c1"># plt.fill(vert_OS[:, 0]+vert_TS[1, 0], vert_OS[:,1]+vert_TS[1, 1], &#39;blue&#39;, alpha=0.3, zorder=2, edgecolor=&#39;black&#39;)</span>
            <span class="c1"># plt.fill(vert_OS[:, 0]+vert_TS[2, 0], vert_OS[:,1]+vert_TS[2, 1], &#39;blue&#39;, alpha=0.3, zorder=2, edgecolor=&#39;black&#39;)</span>
            <span class="c1"># plt.fill(vert_OS[:, 0]+vert_TS[3, 0], vert_OS[:,1]+vert_TS[3, 1], &#39;blue&#39;, alpha=0.3, zorder=2, edgecolor=&#39;black&#39;)</span>
            <span class="n">hullTS</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">vert_TS</span><span class="p">)</span>  <span class="c1"># Shape of TS (just for plotting)</span>
            
            <span class="c1"># plt.fill(exp_vert_TS[hull_exp.vertices, 0]+pos_OS_xy[0],</span>
            <span class="c1">#           exp_vert_TS[hull_exp.vertices, 1]+pos_OS_xy[1], &#39;orange&#39;,</span>
            <span class="c1">#           alpha=1, zorder=0.1, edgecolor=&#39;black&#39;)</span>
            <span class="k">if</span> <span class="n">plotvar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">vert_TS</span><span class="p">[</span><span class="n">hullTS</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vert_TS</span><span class="p">[</span><span class="n">hullTS</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;TS 1&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">exp_vert_TS_safe</span><span class="p">[</span><span class="n">hull_safe</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">exp_vert_TS_safe</span><span class="p">[</span><span class="n">hull_safe</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;safety area </span><span class="se">\n</span><span class="s2">around TS&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">vert_OS</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vert_OS</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span><span class="n">hatch</span><span class="o">=</span><span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;OS&quot;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">plotvar</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">vert_TS</span><span class="p">[</span><span class="n">hullTS</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vert_TS</span><span class="p">[</span><span class="n">hullTS</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;||&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;TS 2&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">exp_vert_TS_safe</span><span class="p">[</span><span class="n">hull_safe</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">exp_vert_TS_safe</span><span class="p">[</span><span class="n">hull_safe</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

        <span class="c1"># Plot the position of OS and TS / optional vertices of the poylgon</span>
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="c1"># plt.scatter(vert_hull[:,0], vert_hull[:,1], marker=&#39;.&#39;, linewidths=(0.1))</span>
            
            <span class="c1"># Plot the origin point of OS and TS</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pos_TS_rel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_TS_rel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the vertices of the polygon from the hull object</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hull_safe</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="n">vert_hull</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hull_safe</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        
        <span class="n">vert_hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">)</span>
        <span class="n">vert_hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">,</span> <span class="p">(</span><span class="n">hull_safe</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
        
        <span class="c1"># Checking if the OS is colliding with the safety area</span>
        <span class="n">safety_area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">safety_area</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coll_safety</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coll_safety</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="c1"># Find the tangent lines by checking which vertices has the greatest angle in between</span>
        <span class="n">rel_angles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Calculate the angle between all vertices points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">180</span><span class="p">):</span>
                    <span class="n">rel_angles_raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
                        <span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">rel_angles_raw</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">rel_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
                            <span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">360</span><span class="p">)),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rel_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
                            <span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">360</span><span class="p">)),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rel_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
                        <span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="n">rel_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rel_angles</span><span class="p">)</span>            
        <span class="n">rel_angles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">rel_angles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Find the greatest angle in positive or negative direction</span>
        <span class="n">abs_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rel_angles</span><span class="p">)</span>

        <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">abs_angles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">tang_vert</span> <span class="o">=</span> <span class="n">abs_angles</span><span class="p">[</span><span class="n">max_index</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">rel_angles</span><span class="p">[</span><span class="n">max_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Take all vertices between the max angle vertix and min angle vertix</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vert_hull_facing</span> <span class="o">=</span> <span class="n">vert_hull</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span>
                <span class="n">tang_vert</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span><span class="n">tang_vert</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">sign</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vert_hull_facing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">vert_hull</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span>
                <span class="n">tang_vert</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span><span class="n">tang_vert</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Change the order of the coordinates, so that the index of the max angle is on 0. So that the plot later on is correct</span>
            <span class="n">vert_hull_facing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">vert_hull_facing</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span>
                <span class="n">tang_vert</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">vert_hull_facing</span><span class="p">[:</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span><span class="n">tang_vert</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># extract the two tangent points so that they can be added to the VO later on</span>
        <span class="n">tang_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">vert_hull_facing</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vert_hull_facing</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                                <span class="p">[</span><span class="n">vert_hull_facing</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_hull_facing</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                <span class="n">vert_hull_facing</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_hull_facing</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span>
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">tang_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">vert_hull_facing</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vert_hull_facing</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                                <span class="p">[</span><span class="n">vert_hull_facing</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_hull_facing</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                <span class="n">vert_hull_facing</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_hull_facing</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span><span class="o">*</span><span class="mi">1</span>
        
        <span class="c1"># Collision Cone (CC)</span>
        <span class="n">coll_cone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">tang_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span> <span class="c1"># (Just for plotting)</span>
        
        <span class="n">tang_points_shift</span> <span class="o">=</span> <span class="n">tang_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tang_points_shift</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tang_points_shift</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tang_points_shift</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tang_points_shift</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Calulate the shifted vertices by TTC</span>
        <span class="n">vert_hull_TTC</span> <span class="o">=</span> <span class="n">vert_hull_facing</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">max_TTC</span>
        
        <span class="c1"># Collision Cone with time contrains (CC)</span>
        <span class="n">coll_cone_TTC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">tang_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">vert_hull_TTC</span><span class="p">,</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span> <span class="c1"># (Just for plotting)</span>
        
        <span class="c1"># Plot the minimum speed shifted with the velocity of TS</span>
        <span class="n">vert_hull_TTC_shifted</span> <span class="o">=</span> <span class="n">vert_hull_TTC</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vert_hull_TTC_shifted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vert_hull_TTC_shifted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vert_hull_TTC_shifted</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vert_hull_TTC_shifted</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># VO without unc and without time contrains</span>
        <span class="n">vert_VO_no_unc_ttc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">tang_points_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="p">[</span><span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">tang_points_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span> <span class="c1"># (Just for plotting)</span>
        
        <span class="c1"># Calculate all points if the vertices TTC_shifted with the circle</span>

        <span class="c1"># Line equation for points between shifted tangent points and shifted origin</span>
        <span class="c1"># line of the side the COLREG contrains has to be on</span>
        <span class="n">x_p1</span> <span class="o">=</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_p1</span> <span class="o">=</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x_p2</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># left tangent point</span>
        <span class="n">y_p2</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># left tangent point</span>
        <span class="n">x_p3</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># right tangent point</span>
        <span class="n">y_p3</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># right tangent point</span>
        <span class="n">m_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_p2</span><span class="o">-</span><span class="n">y_p1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x_p2</span><span class="o">-</span><span class="n">x_p1</span><span class="p">)</span>  <span class="c1"># left line seen from OS</span>
        <span class="n">m_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_p3</span><span class="o">-</span><span class="n">y_p1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x_p3</span><span class="o">-</span><span class="n">x_p1</span><span class="p">)</span>  <span class="c1"># right line seen from OS</span>

        <span class="c1"># add uncertainties</span>
        <span class="n">vert_VO_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">tang_points_shift</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="n">vert_hull_TTC_shifted</span><span class="p">,</span> <span class="n">tang_points_shift</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">vert_VO_testo_unc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_uncert</span><span class="p">(</span><span class="n">vert_VO_testo</span><span class="p">,</span> <span class="n">pos_TS_rel</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">)</span>
        <span class="n">vert_VO_unc_no_TTC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_uncert</span><span class="p">(</span><span class="n">vert_VO_no_unc_ttc</span><span class="p">,</span> <span class="n">pos_TS_rel</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">)</span> <span class="c1"># (Just for plotting)</span>
        
        <span class="c1"># find the line parallel to the VO of the VO_unc</span>
        <span class="n">b_l</span> <span class="o">=</span> <span class="n">vert_VO_testo_unc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m_1</span> <span class="o">*</span> <span class="n">vert_VO_testo_unc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">b_l</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">most_common</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b_1</span> <span class="o">=</span> <span class="n">most_common</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">b_r</span> <span class="o">=</span> <span class="n">vert_VO_testo_unc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m_2</span> <span class="o">*</span> <span class="n">vert_VO_testo_unc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">b_r</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">most_common</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b_2</span> <span class="o">=</span> <span class="n">most_common</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># # intersection of the two tangent lines added with unc</span>
        <span class="c1"># x_inters = (b_1-b_2)/(m_2-m_1)</span>
        <span class="c1"># y_inters = m_1*x_inters + b_1</span>
        <span class="c1"># point_tipp = np.array([x_inters, y_inters])</span>
        
        <span class="c1"># find index of the value b_1 in b_l</span>
        <span class="c1"># find index of the value b_2 in b_r</span>
        <span class="n">index_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">b_l</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="n">b_1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">b_r</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="n">b_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Calculate distance of the two each indices, take the one with the furthest distance</span>
        <span class="n">distance_i_l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">distance_i_r</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">index_l</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                            <span class="o">+</span> <span class="p">(</span><span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">distance_i_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">index_r</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                            <span class="o">+</span> <span class="p">(</span><span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">distance_i_r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

        <span class="n">distance_i_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distance_i_l</span><span class="p">)</span>
        <span class="n">distance_i_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distance_i_r</span><span class="p">)</span>
        <span class="n">index_p_l</span> <span class="o">=</span> <span class="n">index_l</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance_i_l</span><span class="p">)]</span>
        <span class="n">index_p_r</span> <span class="o">=</span> <span class="n">index_r</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance_i_r</span><span class="p">)]</span>
        
        <span class="c1"># Extract the unc vertices</span>
        <span class="k">if</span> <span class="n">index_p_l</span> <span class="o">&gt;</span> <span class="n">index_p_r</span><span class="p">:</span>
            
            <span class="n">vert_hull_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">index_p_l</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">vert_VO_testo_unc</span><span class="p">[:</span><span class="n">index_p_r</span><span class="o">+</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index_p_l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">vert_hull_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">index_p_l</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">vert_VO_testo_unc</span><span class="p">[:</span><span class="n">index_p_r</span><span class="o">+</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">index_p_r</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_VO_testo_unc</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">vert_hull_unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">index_p_l</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span><span class="n">vert_VO_testo_unc</span><span class="p">[:</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vert_hull_unc</span> <span class="o">=</span> <span class="n">vert_VO_testo_unc</span><span class="p">[</span><span class="n">index_p_l</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">index_p_r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># VO with unc and TTC</span>
        <span class="n">vel_obst_TTC_unc</span> <span class="o">=</span> <span class="n">vert_hull_unc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="c1"># plt.quiver(0, 0, vel_Relxy[0], vel_Relxy[1], scale=1, scale_units=&#39;xy&#39;, angles=&#39;xy&#39;, color=&#39;purple&#39;, zorder=2, width=0.01)</span>
            <span class="c1"># plt.annotate(&#39;$V_{OS}-V_{TS}$&#39;, (vel_Relxy[0],vel_Relxy[1]), (vel_Relxy[0]+1.5,vel_Relxy[1]-2), c=&quot;purple&quot;)</span>
            <span class="k">if</span> <span class="n">plotvar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vel_OSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vel_OSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;v</span><span class="se">\u20D7</span><span class="s2"> ships&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">pos_TS_rel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_TS_rel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.005</span><span class="p">)</span>
            <span class="c1"># plt.quiver(0, 0, vel_TSxy[0], vel_TSxy[1],</span>
            <span class="c1">#             scale=1, scale_units=&#39;xy&#39;, angles=&#39;xy&#39;, color=&#39;black&#39;,</span>
            <span class="c1">#             zorder=2, width=0.0051)</span>
            <span class="c1"># plt.annotate(&#39;$V_{TS}$&#39;, (vel_TSxy[0],vel_TSxy[1]), ((vel_TSxy[0]-2.3),(vel_TSxy[1]-1.5)),c=&quot;black&quot;)</span>
            <span class="c1"># plt.quiver(tang_points[0,0],tang_points[0,1],vel_TSxy[0], vel_TSxy[1],</span>
            <span class="c1">#             scale=1, scale_units=&#39;xy&#39;, angles=&#39;xy&#39;, color=&#39;red&#39;,</span>
            <span class="c1">#             zorder=2, width=0.0051)</span>
            <span class="c1"># plt.annotate(&#39;$V_{TS}$&#39;, (tang_points[0,0]+vel_TSxy[0],tang_points[0,1]+vel_TSxy[1]), ((vel_TSxy[0]+tang_points[0,0]-2.3),(vel_TSxy[1]+tang_points[0,1]+1.2)))</span>
            <span class="c1"># plt.quiver(tang_points[1,0],tang_points[1,1],vel_TSxy[0], vel_TSxy[1],</span>
            <span class="c1">#             scale=1, scale_units=&#39;xy&#39;, angles=&#39;xy&#39;, color=&#39;red&#39;,</span>
            <span class="c1">#             zorder=2, width=0.0051)</span>
            <span class="c1"># plt.annotate(&#39;$V_{TS}$&#39;, (tang_points[1,0]+vel_TSxy[0],tang_points[1,1]+vel_TSxy[1]), ((vel_TSxy[0]+tang_points[1,0]-0.5),(vel_TSxy[1]+tang_points[1,1]-2)))</span>
            <span class="c1"># plt.plot(coll_cone[:,0], coll_cone[:,1], &quot;lightgray&quot;, zorder=0)</span>
            <span class="c1"># plt.fill(coll_cone[:,0], coll_cone[:,1], &quot;white&quot;, zorder=0)</span>
            <span class="c1"># plt.annotate(&quot;CC&quot;, (9,15),c=&quot;dimgray&quot;)</span>
            <span class="c1"># plt.plot(coll_cone_TTC[:,0], coll_cone_TTC[:,1], &quot;gray&quot;, zorder=0.001)</span>
            <span class="c1"># plt.fill(coll_cone_TTC[:,0], coll_cone_TTC[:,1], &quot;lightgray&quot;, zorder=0.001)</span>
            <span class="c1"># plt.annotate(&quot;CC$^*$&quot;, (9,15),c=&quot;dimgray&quot;)</span>
            <span class="c1"># plt.plot(vert_VO_no_unc_ttc[:,0], vert_VO_no_unc_ttc[:,1], &quot;salmon&quot;,zorder=0)</span>
            <span class="c1"># plt.plot(vel_obst_unc[:,0], vel_obst_unc[:,1], &quot;red&quot;,zorder=0)</span>
            <span class="c1"># plt.plot(vert_VO_testo[:,0], vert_VO_testo[:,1], &quot;black&quot;,zorder=0.02)</span>
            <span class="c1"># plt.fill(vert_VO_testo[:,0], vert_VO_testo[:,1], &quot;salmon&quot;, zorder=0.02)</span>
            <span class="c1"># plt.annotate(&quot;VO&quot;, (4,20),c=&quot;darkred&quot;)</span>
            <span class="c1"># plt.plot(vert_VO_testo_unc[:,0], vert_VO_testo_unc[:,1], &quot;green&quot;)</span>
            <span class="c1"># plt.scatter(pos_TS_rel[0]+vel_TSxy[0],pos_TS_rel[1]+vel_TSxy[1], marker=&quot;x&quot;,c=&quot;black&quot;, s=10, linewidths=(1),zorder=1)</span>
            <span class="c1"># plt.plot(vel_obst_TTC_unc[:,0]+pos_OS_xy[0], vel_obst_TTC_unc[:,1]+pos_OS_xy[1], &quot;black&quot;, zorder=0.01)</span>
            <span class="k">if</span> <span class="n">plotvar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">vel_obst_TTC_unc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vel_obst_TTC_unc</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;VO&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plotvar</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">vel_obst_TTC_unc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vel_obst_TTC_unc</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="c1"># plt.annotate(&#39;OS&#39;, xy=(0,0), xytext=(self.len_OS/2,-1.1))</span>
            <span class="c1"># plt.annotate(&#39;TS&#39;, xy=(pos_TS_rel[0],pos_TS_rel[1]), xytext=(pos_TS_rel[0]+0.5,pos_TS_rel[1]-0))</span>
            <span class="c1"># plt.annotate(&#39;$V_{OS}$&#39;, (vel_OSxy[0],vel_OSxy[1]), (vel_OSxy[0]+0.5,vel_OSxy[1]-2),zorder=6)</span>
            <span class="c1"># plt.annotate(&#39;$V_{TS}$&#39;, (vel_TSxy[0]+pos_TS_rel[0],vel_TSxy[1]+pos_TS_rel[1]), ((vel_TSxy[0]+pos_TS_rel[0]-4),(vel_TSxy[1]+pos_TS_rel[1]+2)))</span>
            
            <span class="c1"># plt.annotate(&#39;Safety area \naround TS \n$TS \oplus (n*\minus OS)$&#39;, xy=(18, 35), xycoords=&#39;data&#39;, xytext=(-102,-13), textcoords=&#39;offset points&#39;, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;angle3,angleA=20,angleB=140&quot;))</span>
            <span class="c1"># plt.annotate(&#39;variable safety \narea around TS&#39;, xy=(30 , 23), xycoords=&#39;data&#39;, xytext=(10, -70), textcoords=&#39;offset points&#39;, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;angle3,angleA=0,angleB=90&quot;))</span>
            <span class="c1"># plt.annotate(&#39;Uncertainty \nin $V_{TS}$ \n(Unc)&#39;, xy=(9.2 , 26), xycoords=&#39;data&#39;, xytext=(-89, 30), textcoords=&#39;offset points&#39;, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;angle3,angleA=0,angleB=90&quot;), bbox=dict(pad=-9, facecolor=&quot;none&quot;, edgecolor=&quot;none&quot;))</span>
            <span class="c1"># plt.annotate(&#39;VO with \nuncertainty \nin $V_{TS}$ \n($VO \oplus Unc$)&#39;, xy=(11, 15), xycoords=&#39;data&#39;, xytext=(10, -70), textcoords=&#39;offset points&#39;, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;angle3,angleA=90,angleB=0&quot;))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vel_obst_TTC_unc</span><span class="p">,</span> <span class="n">vert_hull</span><span class="p">,</span> <span class="n">tang_points</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.add_uncert"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.add_uncert">[docs]</a>    <span class="k">def</span> <span class="nf">add_uncert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_obst</span><span class="p">,</span> <span class="n">posTS_rel</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to add the uncertainties in speed and angle of the TS to the</span>
<span class="sd">        velocity obstacle</span>

<span class="sd">        Args:</span>
<span class="sd">            vel_obst (numpy.array(float)): Vertices forming the velocity obstacle</span>
<span class="sd">            posTS_rel (numpy.array(float)): relative position of the TS to OS (x[m],y[m])</span>
<span class="sd">            vel_TS (numpy.array(float)): Velocity of the TS (speed,angle)</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): Velocity obstacle with added uncertainties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unc_vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_speed</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_angle</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_speed</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_speed</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_angle</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_speed</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_angle</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_speed</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_speed</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">unc_angle</span><span class="p">]])</span>

        <span class="n">vel_TSxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_TS</span><span class="p">)</span>
        <span class="c1"># Vectors to xy component</span>
        <span class="n">unc_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">unc_vel</span><span class="p">)</span>

        <span class="c1"># Plot the uncertainty of vel_TS</span>
        <span class="c1"># plt.scatter(unc_vert[:,0]+posTS_rel[0], unc_vert[:,1]+posTS_rel[1], marker=&#39;.&#39;, linewidths=(0.1))</span>
        <span class="c1"># plt.fil   l(unc_vert[:,0]+posTS_rel[0], unc_vert[:,1]+posTS_rel[1], &#39;green&#39;, alpha=1 ,zorder=1, edgecolor=&#39;black&#39;, linewidth=1.5)</span>

        <span class="n">unc_vert</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">unc_vert</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">unc_vert</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">unc_vert</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">unc_VO</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_minkowski_sum</span><span class="p">(</span><span class="n">vel_obst</span><span class="p">,</span> <span class="n">unc_vert</span><span class="p">)</span>

        <span class="n">unc_VO_hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">unc_VO</span><span class="p">)</span>

        <span class="n">unc_VO_vert</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Extract the vertices of the polygon from the hull object</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unc_VO_hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="n">unc_VO_vert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unc_VO_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

        <span class="c1"># print(hull_safe.vertices.shape[0])</span>
        <span class="n">unc_VO_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unc_VO_vert</span><span class="p">)</span>
        <span class="n">unc_VO_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">unc_VO_vert</span><span class="p">,</span> <span class="p">(</span><span class="n">unc_VO_hull</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># # Plot the vertices of the poylgon</span>
        <span class="c1"># if plotting:</span>
        <span class="c1">#     # plt.scatter(unc_VO_vert[:,0], unc_VO_vert[:,1], marker=&#39;.&#39;, linewidths=(0.1))</span>
        <span class="c1">#     plt.fill(unc_VO[unc_VO_hull.vertices,0], unc_VO[unc_VO_hull.vertices,1], &#39;r&#39;, alpha=1 ,zorder=0.5, edgecolor=&#39;black&#39;, linewidth=1.5)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unc_VO_vert</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.check_coll_point"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.check_coll_point">[docs]</a>    <span class="k">def</span> <span class="nf">check_coll_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_Relxy</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">,</span> <span class="n">vel_OSxy</span><span class="p">,</span> <span class="n">vel_TS</span><span class="p">,</span> <span class="n">vel_TSxy</span><span class="p">,</span> <span class="n">vert_hull</span><span class="p">,</span> <span class="n">tang_points</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to calculate Point of collision, Distance to collision and Time to collision in </span>
<span class="sd">        case the velocity of OS is colliding with the velocity obstacle</span>

<span class="sd">        Args:</span>
<span class="sd">            vel_Relxy (numpy.array(float)): relative velocity of OS towards TS</span>
<span class="sd">            vel_OS (numpy.array(float)): absolute velocity of OS </span>
<span class="sd">            vel_OSxy (numpy.array(float)): absolute velocity of OS in xy-form</span>
<span class="sd">            vel_TS (numpy.array(float)): absolute velocity of TS </span>
<span class="sd">            vel_TSxy (numpy.array(float)): absolute velocity of TS in xy-form</span>
<span class="sd">            vert_hull (numpy.array(float)): vertices of the expanded hull around the TS</span>
<span class="sd">            tang_points (numpy.array(float)): tangent points the CC is formed with</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float), numpy.array(float), numpy.array(float): Point of collision realtive to OS; Distance to collision point from OS; Time to collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate point, where the vel_Rel hits the polygone of the TS</span>
        <span class="c1"># Calculate the relative velocity with magnitude and direction</span>
        <span class="n">vel_Rel_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_ang_mag</span><span class="p">(</span><span class="n">vel_Relxy</span><span class="p">)</span>
        <span class="c1"># Line function of the realtive veloctiy</span>
        <span class="n">m_Rel</span> <span class="o">=</span> <span class="n">vel_Relxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">vel_Relxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b_Rel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># For the intersection point we need a line between two points; take max. x-value of the tangent points to calculate the y-value</span>
        <span class="n">x_line_Rel_1</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">x_line_Rel_2</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">x_line_Rel_1</span> <span class="o">==</span> <span class="n">x_line_Rel_2</span><span class="p">:</span>
            <span class="n">y_line_Rel_1</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">y_line_Rel_2</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_line_Rel_1</span> <span class="o">=</span> <span class="n">m_Rel</span> <span class="o">*</span> <span class="n">x_line_Rel_1</span> <span class="o">+</span> <span class="n">b_Rel</span>
            <span class="n">y_line_Rel_2</span> <span class="o">=</span> <span class="n">m_Rel</span> <span class="o">*</span> <span class="n">x_line_Rel_2</span> <span class="o">+</span> <span class="n">b_Rel</span>
        
        <span class="k">if</span> <span class="mi">0</span><span class="o">-</span><span class="mf">0.001</span> <span class="o">&lt;</span> <span class="n">m_Rel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">+</span><span class="mf">0.001</span><span class="p">:</span>
            <span class="n">line_Rel</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x_line_Rel_2</span><span class="p">,</span> <span class="n">y_line_Rel_2</span><span class="p">)])</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">line_Rel</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">x_line_Rel_1</span><span class="p">,</span> <span class="n">y_line_Rel_1</span><span class="p">),</span> <span class="p">(</span><span class="n">x_line_Rel_2</span><span class="p">,</span> <span class="n">y_line_Rel_2</span><span class="p">)])</span>
        <span class="c1"># plt.plot(*line_Rel.xy, label=&#39;LineString&#39;)</span>
        
        <span class="c1"># Contruct a polygone of the hull points of the polygon</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">vert_hull</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">hull_safe_2</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Check wether the relative velocity is inside the CC or outside, if outside check which side and choose the tangent point of this side</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_side</span><span class="p">(</span><span class="n">vel_Rel_in</span><span class="p">,</span> <span class="n">tang_points</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">pos_TS_rel_coll</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_side</span><span class="p">(</span><span class="n">vel_Rel_in</span><span class="p">,</span> <span class="n">tang_points</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">pos_TS_rel_coll</span> <span class="o">=</span> <span class="n">tang_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_TS_rel_coll</span> <span class="o">=</span> <span class="n">line_Rel</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">hull_safe_2</span><span class="p">)</span>
            <span class="c1"># Check which intersection is close to the OS and choose this one as collision point with the hull</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos_TS_rel_coll</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos_TS_rel_coll</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:])):</span>
                <span class="n">pos_TS_rel_coll</span> <span class="o">=</span> <span class="n">pos_TS_rel_coll</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos_TS_rel_coll</span> <span class="o">=</span> <span class="n">pos_TS_rel_coll</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        
        <span class="c1"># Check wether the TS ans OS are in straight line or speed of the TS is zero</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time_coll</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">pos_TS_rel_coll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos_TS_rel_coll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">dist_coll</span> <span class="o">=</span> <span class="n">vel_OS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">time_coll</span>
            <span class="n">coll_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dist_coll</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">point_coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">coll_vect</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vel_TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">time_coll</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">pos_TS_rel_coll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos_TS_rel_coll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">vel_TS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dist_coll</span> <span class="o">=</span> <span class="n">vel_OS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">time_coll</span>
            <span class="n">coll_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dist_coll</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">point_coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">coll_vect</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate the line function of the velocity vector of OS and TS; Origin point of TS is the intersection point where the OS will collide in</span>
            <span class="n">m_TS</span> <span class="o">=</span> <span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">vel_TSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">m_OS</span> <span class="o">=</span> <span class="n">vel_OSxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">vel_OSxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">b_TS</span> <span class="o">=</span> <span class="n">pos_TS_rel_coll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="p">(</span><span class="n">m_TS</span><span class="o">*</span><span class="n">pos_TS_rel_coll</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">b_OS</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Intersection of the lines (point of collision)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_TS</span><span class="o">-</span><span class="n">b_OS</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">m_OS</span><span class="o">-</span><span class="n">m_TS</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">m_OS</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b_OS</span>
            <span class="n">point_coll</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
 
            <span class="c1"># Distance to collision</span>
            <span class="n">dist_coll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">point_coll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">point_coll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
           
            <span class="c1"># Time to collision</span>
            <span class="n">time_coll</span> <span class="o">=</span> <span class="n">dist_coll</span> <span class="o">/</span> <span class="n">vel_OS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># if plotting:</span>
        <span class="c1">#     plt.scatter(point_coll[0], point_coll[1],</span>
        <span class="c1">#                 marker=&#39;x&#39;, c=&#39;black&#39;, linewidths=(0.7))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point_coll</span><span class="p">,</span> <span class="n">dist_coll</span><span class="p">,</span> <span class="n">time_coll</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.calc_colreg_con"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_colreg_con">[docs]</a>    <span class="k">def</span> <span class="nf">calc_colreg_con</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_TS_xy</span><span class="p">,</span> <span class="n">pos_TS_rel</span><span class="p">,</span><span class="n">colr_rule</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to calculate the COLREG contrains based on the encounter type</span>

<span class="sd">        Args:</span>
<span class="sd">            vel_TS_xy (numpy.array(float)): absolute velocity of TS in yx-form</span>
<span class="sd">            pos_TS_rel (numpy.array(float)): realtive position of TS to OS</span>
<span class="sd">            colr_rule (str): COLREG rule for the specific encounter</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): vertices of the COLREG constrains</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">colreg_con</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">colr_rule</span> <span class="o">==</span> <span class="s1">&#39;Head-on (Rule 14)&#39;</span> <span class="ow">or</span> <span class="n">colr_rule</span> <span class="o">==</span> <span class="s1">&#39;Right crossing (Rule 15)&#39;</span><span class="p">):</span>
            <span class="n">vect_col_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_TS_rel</span> <span class="o">+</span> <span class="n">vel_TS_xy</span><span class="p">)</span> <span class="o">-</span> <span class="n">vel_TS_xy</span>
            <span class="n">perp_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">vect_col_line</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vect_col_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">bound_left</span> <span class="o">=</span> <span class="n">perp_line</span> <span class="o">+</span> <span class="n">vel_TS_xy</span>
            <span class="n">colreg_con</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bound_left</span><span class="p">,</span> <span class="n">vel_TS_xy</span><span class="p">,</span> <span class="p">(</span><span class="n">pos_TS_rel</span> <span class="o">+</span> <span class="n">vel_TS_xy</span><span class="p">)])</span>
            <span class="c1"># if plotting:</span>
            <span class="c1">#     colreg_con_2 = np.array([bound_left_2, vel_TS_xy, (pos_TS_rel + vel_TS_xy)])</span>
            <span class="c1">#     plt.plot(colreg_con_2[:,0], colreg_con_2[:,1], c=&#39;purple&#39;,zorder=0.05)</span>
            <span class="c1">#     plt.plot(colreg_con_2[:,0], colreg_con_2[:,1], c=&#39;purple&#39;,zorder=0.05,linestyle=&#39;dashed&#39;)</span>
            <span class="c1">#     # Add the patch to the Axes</span>
            <span class="c1">#     plt.gca().add_patch(Rectangle((vel_TS_xy[0],vel_TS_xy[1]),3,3,linewidth=1,edgecolor=&#39;purple&#39;,facecolor=&#39;none&#39;, angle=-32))</span>
                <span class="c1"># plt.plot(colreg_con[:,0], colreg_con[:,1], c=&#39;purple&#39;,zorder=0.)</span>
                <span class="c1"># plt.fill(colreg_con[:,0], colreg_con[:,1], c=&#39;purple&#39;,zorder=0, alpha=0.3,linewidth=0.5)</span>
                <span class="c1"># plt.annotate(&quot;COLREG \ncontrains&quot;, (-25,20),c=&quot;purple&quot;)</span>
                <span class="c1"># plt.annotate(&quot;$V_1$&quot;, (-20,20),c=&quot;purple&quot;)</span>
                <span class="c1"># plt.annotate(&quot;$V_2$&quot;, (15,0),c=&quot;purple&quot;)</span>
                <span class="c1"># plt.annotate(&quot;$V_3$&quot;, (-22,-15),c=&quot;purple&quot;)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">colreg_con</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.calc_free_vel_space"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_free_vel_space">[docs]</a>    <span class="k">def</span> <span class="nf">calc_free_vel_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">velobs</span><span class="p">,</span> <span class="n">vel_space_free</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate all velocities that are free of collision</span>

<span class="sd">        Args:</span>
<span class="sd">            velobs : velocity obstacle or colreg contrains</span>
<span class="sd">            vel_space_free : all possible velocities of the OS</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float), numpy.array(float): free velocities outisde the VO; velocities inside the VO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">in_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">vo</span> <span class="ow">in</span> <span class="n">velobs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">vo</span><span class="p">):</span>
                <span class="n">vel_space_free</span><span class="p">,</span> <span class="n">into</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inOutVO</span><span class="p">(</span><span class="n">vel_space_free</span><span class="p">,</span> <span class="n">vo</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">into</span><span class="p">):</span>
                    <span class="n">in_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">in_all</span><span class="p">,</span> <span class="n">into</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">vel_space_free</span><span class="p">,</span> <span class="n">in_all</span></div>

<div class="viewcode-block" id="VO.calc_new_vel_overtaking"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_new_vel_overtaking">[docs]</a>    <span class="k">def</span> <span class="nf">calc_new_vel_overtaking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_des</span><span class="p">,</span> <span class="n">search_area</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to calculate the new velocity for encounters, where no COLREG</span>
<span class="sd">        constrains are applied </span>

<span class="sd">        Args:</span>
<span class="sd">            vel_des (numpy.array(float)): absolute desired velocity of OS</span>
<span class="sd">            search_area (numpy.array(float)): free velocities outside of VO and COLREG contrains</span>
<span class="sd">            vel_OS (numpy.array(float)): absolute current velocity of OS</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): velocity to avoid a collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">search_area</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_safety</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># Calculate new vel</span>
            <span class="n">vel_space_free_xy</span> <span class="o">=</span> <span class="n">search_area</span>
            <span class="n">vel_space_free_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">vel_space_free_xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Cost function to choose new velocity</span>
            <span class="n">in_arcos_des</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_des</span><span class="p">))</span>
                            <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vel_space_free_mag</span><span class="o">*</span><span class="n">vel_des</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">in_arcos_des</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">in_arcos_des</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">angles_des_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">in_arcos_des</span><span class="p">))</span>
            
            <span class="n">speed_des_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vel_space_free_mag</span> <span class="o">-</span> <span class="n">vel_des</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">vel_30</span> <span class="o">=</span> <span class="n">vel_OS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_30</span><span class="p">))</span>
                                <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vel_space_free_mag</span><span class="o">*</span><span class="n">vel_30</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">angles_30_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">))</span>
                                        
                <span class="n">angles_30_free</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="o">-</span><span class="n">angles_30_free</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span>
                <span class="n">angles_30_free</span><span class="p">[</span><span class="n">angles_30_free</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">angles_30_free</span> <span class="o">=</span> <span class="o">-</span><span class="n">angles_30_free</span>
                <span class="n">angles_30_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">angles_30_free</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vel_30</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vel_30</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">30</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
                <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_30</span><span class="p">))</span>
                                <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vel_space_free_mag</span><span class="o">*</span><span class="n">vel_30</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">angles_30_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">vel_30</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vel_30</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">30</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
                <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_30</span><span class="p">))</span>
                                <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vel_space_free_mag</span><span class="o">*</span><span class="n">vel_30</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">angles_30_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">))</span>

            <span class="c1"># Normalize the values between 0-1, with 0 = 0 and 1 = max value</span>
            <span class="n">norm_ang_des_free</span> <span class="o">=</span> <span class="n">angles_des_free</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">angles_des_free</span><span class="p">)</span>
            <span class="n">norm_speed_des_free</span> <span class="o">=</span> <span class="n">speed_des_free</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">speed_des_free</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">angles_30_free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">norm_ang_30_free</span> <span class="o">=</span> <span class="n">angles_30_free</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_ang_30_free</span> <span class="o">=</span> <span class="n">angles_30_free</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">angles_30_free</span><span class="p">)</span>
                
            <span class="c1"># Cost function</span>
            <span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="n">VO</span><span class="o">.</span><span class="n">w_1</span> <span class="o">*</span> <span class="n">norm_ang_des_free</span> <span class="o">+</span> <span class="n">VO</span><span class="o">.</span><span class="n">w_2</span> <span class="o">*</span> <span class="n">norm_speed_des_free</span> <span class="o">+</span>
                <span class="n">VO</span><span class="o">.</span><span class="n">w_3</span> <span class="o">*</span> <span class="n">norm_ang_30_free</span><span class="p">)</span>
        
            <span class="c1"># Extract index and plot the new velocity</span>
            <span class="n">index_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
            <span class="n">new_vel_xy</span> <span class="o">=</span> <span class="p">([</span><span class="n">vel_space_free_xy</span><span class="p">[</span><span class="n">index_j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">vel_space_free_xy</span><span class="p">[</span><span class="n">index_j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            
            <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_ang_mag</span><span class="p">(</span><span class="n">new_vel_xy</span><span class="p">)</span>
            
            <span class="c1"># if plotting:</span>
            <span class="c1">#     plt.quiver(0, 0, new_vel_xy[0], new_vel_xy[1], scale=1,</span>
            <span class="c1">#                 scale_units=&#39;xy&#39;, angles=&#39;xy&#39;, color=&#39;blue&#39;, zorder=6)</span>
            <span class="c1">#     plt.annotate(&#39;$V_{new}$&#39;, (new_vel_xy[0],new_vel_xy[1]), (new_vel_xy[0]+0,new_vel_xy[1]-1), zorder=6, c=&quot;blue&quot;)</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&quot;No velocity is outside the velocity obstacle&quot;)</span>
            <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latest_new_vel</span>
            <span class="c1"># new_vel = []</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_vel</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.calc_new_vel"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_new_vel">[docs]</a>    <span class="k">def</span> <span class="nf">calc_new_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel_des</span><span class="p">,</span> <span class="n">search_area</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to calculate the new velocity for encounters, where COLREG</span>
<span class="sd">        constrains are applied </span>

<span class="sd">        Args:</span>
<span class="sd">            vel_des (numpy.array(float)): absolute desired velocity of OS</span>
<span class="sd">            search_area (numpy.array(float)): free velocities outside of VO and COLREG contrains</span>
<span class="sd">            vel_OS (numpy.array(float)): absolute current velocity of OS</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): velocity to avoid a collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">search_area</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_safety</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">vel_space_free_xy</span> <span class="o">=</span> <span class="n">search_area</span>
            <span class="n">vel_space_free_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">vel_space_free_xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
            <span class="n">in_arcos_des</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_des</span><span class="p">))</span>
                            <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vel_space_free_mag</span><span class="o">*</span><span class="n">vel_des</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">in_arcos_des</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">in_arcos_des</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">angles_des_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">in_arcos_des</span><span class="p">))</span>
        
            <span class="n">speed_des_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vel_space_free_mag</span> <span class="o">-</span> <span class="n">vel_des</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">vel_30</span> <span class="o">=</span> <span class="n">vel_OS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">vel_30</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vel_30</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">30</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
            <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_space_free_xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_30</span><span class="p">))</span>
                            <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vel_space_free_mag</span><span class="o">*</span><span class="n">vel_30</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">in_arcos_30</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">angles_30_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">in_arcos_30</span><span class="p">))</span>

            <span class="c1"># Normalize the values between 0-1, with 0 = 0 and 1 = max value</span>
            <span class="n">norm_ang_des_free</span> <span class="o">=</span> <span class="n">angles_des_free</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">angles_des_free</span><span class="p">)</span>
            <span class="n">norm_speed_des_free</span> <span class="o">=</span> <span class="n">speed_des_free</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">speed_des_free</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">angles_30_free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">norm_ang_30_free</span> <span class="o">=</span> <span class="n">angles_30_free</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm_ang_30_free</span> <span class="o">=</span> <span class="n">angles_30_free</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">angles_30_free</span><span class="p">)</span>
        
            <span class="c1"># Cost function</span>
            <span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="n">VO</span><span class="o">.</span><span class="n">w_1</span> <span class="o">*</span> <span class="n">norm_ang_des_free</span> <span class="o">+</span> <span class="n">VO</span><span class="o">.</span><span class="n">w_2</span> <span class="o">*</span>
                <span class="n">norm_speed_des_free</span> <span class="o">+</span> <span class="n">VO</span><span class="o">.</span><span class="n">w_3</span> <span class="o">*</span> <span class="n">norm_ang_30_free</span><span class="p">)</span>
        
            <span class="c1"># Extract index and plot the new velocity</span>
            <span class="n">index_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
            <span class="n">new_vel_xy</span> <span class="o">=</span> <span class="p">([</span><span class="n">vel_space_free_xy</span><span class="p">[</span><span class="n">index_j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">vel_space_free_xy</span><span class="p">[</span><span class="n">index_j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_ang_mag</span><span class="p">(</span><span class="n">new_vel_xy</span><span class="p">)</span>
            <span class="c1"># if plotting:</span>
            <span class="c1">#     plt.quiver(0, 0, new_vel_xy[0], new_vel_xy[1], scale=1,</span>
            <span class="c1">#                scale_units=&#39;xy&#39;, angles=&#39;xy&#39;, color=&#39;blue&#39;, zorder=4, width=0.003)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&quot;No velocity is outside the velocity obstacle&quot;)</span>
            <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latest_new_vel</span>
            <span class="c1"># new_vel = []</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_vel</span><span class="p">)</span></div>

<div class="viewcode-block" id="VO.extract_most_common_vel"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.extract_most_common_vel">[docs]</a>    <span class="k">def</span> <span class="nf">extract_most_common_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to calculate the most common velocity&quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
        <span class="n">similar_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distances</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">most_common_index</span> <span class="o">=</span> <span class="n">mode</span><span class="p">(</span><span class="n">similar_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">most_common_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="VO.calc_vel_final"><a class="viewcode-back" href="../../asv_path_planner.html#asv_path_planner.velobst_class.VO.calc_vel_final">[docs]</a>    <span class="k">def</span> <span class="nf">calc_vel_final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts_info</span><span class="p">,</span> <span class="n">os_info</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">pos_os</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the veloctiy obstacle and COLREG contrains for all TS and calculate the optimal velocity to avoid a collision</span>

<span class="sd">        Args:</span>
<span class="sd">            ts_info (list(class object)):  Object of the class TS with information about the target ship (see `Target Ship (TS) module`_)</span>
<span class="sd">            os_info (numpy.array(objects)): Array with information about the own ship (current velocity (speed, angle); desired velocity (speed, angle))</span>
<span class="sd">            this (_type_): only needed for plotting</span>
<span class="sd">            pos_os (_type_): only needed for plotting</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array(float): optimal velocity for OS to avoid a collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">plotting</span>
        <span class="n">plotting</span> <span class="o">=</span> <span class="n">this</span>
        <span class="k">global</span> <span class="n">pos_OS_xy</span>
        <span class="n">pos_OS_xy</span> <span class="o">=</span> <span class="n">pos_os</span>

        <span class="c1"># if plotting:</span>
        <span class="c1">#     # Create a circle around the OS with the maximum speed of the OS --&gt; all possible velocities of OS</span>
        <span class="c1">#     # Parametric equation circle</span>
        <span class="c1">#     c_angle = np.linspace(0, np.deg2rad(360), 150)</span>
        <span class="c1">#     x = self.max_speed_OS * np.cos(c_angle)</span>
        <span class="c1">#     y = self.max_speed_OS * np.sin(c_angle)</span>
        <span class="c1">#     # List of all circle points = c_points</span>
        <span class="c1">#     c_points = np.column_stack((x, y))</span>
        <span class="c1">#     c_points[:,0] = c_points[:,0] + pos_OS_xy[0]</span>
        <span class="c1">#     c_points[:,1] = c_points[:,1] + pos_OS_xy[1]</span>
        <span class="c1">#     plt.plot(c_points[:, 0], c_points[:, 1], &#39;black&#39;,zorder=6)</span>
        <span class="c1">#     plt.fill(c_points[:, 0], c_points[:, 1], &#39;lightgray&#39;,</span>
        <span class="c1">#               alpha=0.5, zorder=0, edgecolor=&#39;black&#39;, linewidth=1.5)</span>
        
        <span class="n">vel_OS</span> <span class="o">=</span> <span class="n">os_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">global</span> <span class="n">vel_OSxy</span>
        <span class="n">vel_OSxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">)</span>
        <span class="n">ang_OS_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vel_des</span> <span class="o">=</span> <span class="n">os_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vel_des_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_des</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_OS_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vel_des_xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vel_des_xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s2">&quot;||||&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;v</span><span class="se">\u20D7</span><span class="s2"> desired&quot;</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">plotvar</span>
        <span class="n">plotvar</span> <span class="o">=</span> <span class="mi">1</span>     
        <span class="c1"># for each TS --&gt; calc VO with uncertainties</span>
        <span class="n">TS_VO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">TSo</span> <span class="ow">in</span> <span class="n">ts_info</span><span class="p">:</span>
            <span class="n">plotvar</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">vel_TS_ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">TSo</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">ang</span><span class="p">])</span>
            <span class="n">vel_TS_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_TS_ang</span><span class="p">)</span>
            <span class="n">vel_rela</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_rel_vel</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">,</span> <span class="n">vel_TS_ang</span><span class="p">)</span>
            <span class="n">vel_rela_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vect_to_xy</span><span class="p">(</span><span class="n">vel_rela</span><span class="p">)</span>

            <span class="c1"># Calculate the velocity obstacle (VO)</span>
            <span class="n">VOs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_vel_obst</span><span class="p">(</span><span class="n">TSo</span><span class="p">,</span> <span class="n">ang_OS_rad</span><span class="p">)</span>
            <span class="n">TSo</span><span class="o">.</span><span class="n">vo</span> <span class="o">=</span> <span class="n">VOs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">TSo</span><span class="o">.</span><span class="n">vert_hull</span> <span class="o">=</span> <span class="n">VOs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">TSo</span><span class="o">.</span><span class="n">tang_points</span> <span class="o">=</span> <span class="n">VOs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                       
            <span class="c1"># Check if the current velocity and desired velocity of OS are inside VO</span>
            <span class="n">TSo</span><span class="o">.</span><span class="n">coll_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_collision</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">vo</span><span class="p">)</span>
            <span class="n">TSo</span><span class="o">.</span><span class="n">coll_check_des</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_collision</span><span class="p">(</span><span class="n">vel_des</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">vo</span><span class="p">)</span>

            <span class="c1"># Check the COLREG rule and calculate the COLREG constrains</span>
            <span class="k">if</span> <span class="n">TSo</span><span class="o">.</span><span class="n">coll_check</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span> <span class="o">=</span> <span class="n">vel_OS</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_colreg_rule_heading</span><span class="p">(</span><span class="n">vel_OS</span><span class="p">,</span> <span class="n">vel_TS_ang</span><span class="p">)</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colreg_con</span><span class="p">(</span><span class="n">vel_TS_xy</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_rule</span><span class="p">)</span>
                <span class="n">Coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_coll_point</span><span class="p">(</span>
                    <span class="n">vel_rela_xy</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">,</span> <span class="n">vel_OSxy</span><span class="p">,</span> <span class="n">vel_TS_ang</span><span class="p">,</span> <span class="n">vel_TS_xy</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">vert_hull</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">tang_points</span><span class="p">)</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_point</span> <span class="o">=</span> <span class="n">Coll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_dist</span> <span class="o">=</span> <span class="n">Coll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_time</span> <span class="o">=</span> <span class="n">Coll</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">TSo</span><span class="o">.</span><span class="n">coll_check</span> <span class="ow">and</span> <span class="n">TSo</span><span class="o">.</span><span class="n">coll_check_des</span> <span class="ow">and</span> <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colreg_con</span><span class="p">(</span><span class="n">vel_TS_xy</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_rule</span><span class="p">)</span>
                <span class="n">Coll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_coll_point</span><span class="p">(</span>
                    <span class="n">vel_rela_xy</span><span class="p">,</span> <span class="n">vel_OS</span><span class="p">,</span> <span class="n">vel_OSxy</span><span class="p">,</span> <span class="n">vel_TS_ang</span><span class="p">,</span> <span class="n">vel_TS_xy</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">vert_hull</span><span class="p">,</span> <span class="n">TSo</span><span class="o">.</span><span class="n">tang_points</span><span class="p">)</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_point</span> <span class="o">=</span> <span class="n">Coll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_dist</span> <span class="o">=</span> <span class="n">Coll</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_time</span> <span class="o">=</span> <span class="n">Coll</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">os_init</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">colreg_con</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_point</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_dist</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">TSo</span><span class="o">.</span><span class="n">coll_time</span> <span class="o">=</span> <span class="p">[]</span>
          
        <span class="c1">### TS_VO_check = (pos_TS_rel, len_TS, wid_TS, speed_TS, ang_TS, VO_vert, hull_vert, tang_points,  Check_coll, col_rule, col_con, point_coll,dist_coll, time_coll)</span>
        <span class="n">vo_added</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">vo</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ts_info</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">col_con_added</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">colreg_con</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ts_info</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="c1"># if np.any(TS_VO_check[:,9]):</span>
        <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>    
            <span class="c1"># Create the possible velocities to search a new vel from</span>
            <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_ang</span><span class="p">))</span>
            <span class="n">vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.000000000001</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_speed_OS</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">res_speed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_speed</span><span class="p">)</span>
            <span class="n">vv</span><span class="p">,</span> <span class="n">thth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">vel</span><span class="p">,</span> <span class="n">th</span><span class="p">)</span>
            <span class="n">vx_sample</span> <span class="o">=</span> <span class="p">(</span><span class="n">vv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thth</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">vy_sample</span> <span class="o">=</span> <span class="p">(</span><span class="n">vv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thth</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">v_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">vx_sample</span><span class="p">,</span> <span class="n">vy_sample</span><span class="p">))</span>
            
            <span class="c1"># Calculate free vel space --&gt; all velocities - VOs - COLREG cons</span>
            <span class="n">free_vel</span><span class="p">,</span> <span class="n">in_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_free_vel_space</span><span class="p">(</span><span class="n">vo_added</span><span class="p">,</span> <span class="n">v_sample</span><span class="p">)</span>
            <span class="n">free_vel</span><span class="p">,</span> <span class="n">col_con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_free_vel_space</span><span class="p">(</span><span class="n">col_con_added</span><span class="p">,</span> <span class="n">free_vel</span><span class="p">)</span>
            <span class="c1"># if np.any(free_vel) and plotting:</span>
            <span class="c1">#     plt.scatter(free_vel[:,0]+pos_OS_xy[0],free_vel[:,1]+pos_OS_xy[1], marker=&quot;.&quot;, s = 2, c=&quot;green&quot;, zorder=5)</span>
            <span class="c1">#     plt.scatter(in_all[:,0]+pos_OS_xy[0],in_all[:,1]+pos_OS_xy[1], marker=&quot;.&quot;, s = 2, c=&quot;red&quot;,zorder=5)</span>
            <span class="c1">#     plt.scatter(col_con[:,0]+pos_OS_xy[0],col_con[:,1]+pos_OS_xy[1], marker=&quot;.&quot;, s = 2, c=&quot;purple&quot;,zorder=5)</span>
                <span class="c1"># plt.annotate(&quot;Discretized velocity space&quot;, xy=(0, -15), xycoords=&#39;data&#39;, xytext=(-102,-25), textcoords=&#39;offset points&#39;, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;angle3,angleA=0,angleB=90&quot;),zorder=6)</span>
                
                <span class="c1"># ## polar plot for display</span>
                <span class="c1"># free_vel_1 = np.apply_along_axis(self.vect_to_ang_mag, 1, free_vel)</span>
                <span class="c1"># in_all_1 = np.apply_along_axis(self.vect_to_ang_mag, 1, in_all)</span>
                <span class="c1"># col_con_1 = np.apply_along_axis(self.vect_to_ang_mag, 1, col_con)</span>
                <span class="c1"># plt.rcParams[&quot;figure.figsize&quot;] = [7.00, 3.50]</span>
                <span class="c1"># plt.rcParams[&quot;figure.autolayout&quot;] = True</span>
                <span class="c1"># ax = plt.subplot(1, 1, 1, projection=&#39;polar&#39;)</span>
                <span class="c1"># ax.set_theta_direction(-1)</span>
                <span class="c1"># ax.set_theta_offset(np.pi / 2.0)</span>
                <span class="c1"># ax.scatter(np.deg2rad(free_vel_1[:,1]), free_vel_1[:,0], c=&quot;green&quot;, s=1, zorder=5)</span>
                <span class="c1"># ax.scatter(np.deg2rad(in_all_1[:,1]), in_all_1[:,0], c=&quot;red&quot;,s=1,zorder=5)</span>
                <span class="c1"># ax.scatter(np.deg2rad(col_con_1[:,1]), col_con_1[:,0], c=&quot;purple&quot;,s=1,zorder=5)</span>
    
            <span class="c1"># if all velocities would lead to a collision, expand the free vel space by the colreg constrains, so that a colreg non-compliant action is possible</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">free_vel</span><span class="p">):</span>
                <span class="n">free_vel</span> <span class="o">=</span> <span class="n">col_con</span>        
        <span class="c1"># Calculate new velocities for each VO the OS vel is colliding with</span>
        <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">TS_vel</span> <span class="ow">in</span> <span class="n">ts_info</span><span class="p">:</span>
            <span class="c1"># for each TS with collision and COLREG rules where contrains have to be applied, calculate the new velocity in free velocity space</span>
            <span class="k">if</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="s1">&#39;Right crossing (Rule 15)&#39;</span> <span class="ow">or</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="s1">&#39;Head-on (Rule 14)&#39;</span> <span class="ow">or</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="s1">&#39;Overtaking (Rule 13)&#39;</span><span class="p">:</span>

                <span class="c1"># Calculate new velocity</span>
                <span class="k">if</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="s1">&#39;Overtaking (Rule 13)&#39;</span><span class="p">:</span>
                    <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_new_vel_overtaking</span><span class="p">(</span><span class="n">vel_des</span><span class="p">,</span> <span class="n">free_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_vel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_vel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_new_vel</span><span class="p">(</span><span class="n">vel_des</span><span class="p">,</span> <span class="n">free_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_vel</span><span class="p">):</span>
                    <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="n">new_vel</span><span class="p">,</span> <span class="n">new_vel</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))))</span>
            <span class="c1"># for each TS with collision and no COLREG constrains have to be applied, calculate the new velocity in free velocity space</span>
            <span class="k">elif</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="s1">&#39;Left crossing (Rule 15)&#39;</span> <span class="ow">or</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="s1">&#39;Being Overtaken (Rule 13)&#39;</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">coll_time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                    <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_new_vel</span><span class="p">(</span><span class="n">vel_des</span><span class="p">,</span> <span class="n">free_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_vel</span><span class="p">):</span>
                        <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="n">new_vel</span><span class="p">))</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="n">TS_vel</span><span class="o">.</span><span class="n">colreg_rule</span> <span class="o">==</span> <span class="s1">&#39;Static object&#39;</span><span class="p">:</span>
                <span class="n">new_vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_new_vel_overtaking</span><span class="p">(</span><span class="n">vel_des</span><span class="p">,</span> <span class="n">free_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_vel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_OS_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_vel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">hyst_flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_vel</span><span class="p">):</span>
                    <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="n">new_vel</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_vel_testo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))))</span>
        
        <span class="c1"># Extract the final new velocity</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">new_vel_testo</span><span class="p">):</span>
            <span class="n">is_inside</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">vel_obs</span> <span class="ow">in</span> <span class="n">vo_added</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_collision</span><span class="p">(</span><span class="n">vel_des</span><span class="p">,</span> <span class="n">vel_obs</span><span class="p">):</span>
                    
                    <span class="n">is_inside</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_inside</span><span class="p">:</span>
                <span class="n">new_vel_final</span> <span class="o">=</span> <span class="n">vel_des</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_vel_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_most_common_vel</span><span class="p">(</span><span class="n">new_vel_testo</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
           
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_inside</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">vel_obs</span> <span class="ow">in</span> <span class="n">vo_added</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_collision</span><span class="p">(</span><span class="n">vel_des</span><span class="p">,</span> <span class="n">vel_obs</span><span class="p">):</span>
                    
                    <span class="n">is_inside</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_inside</span><span class="p">:</span>
                <span class="n">new_vel_final</span> <span class="o">=</span> <span class="n">vel_des</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latest_new_vel</span><span class="p">):</span>
                <span class="n">new_vel_final</span> <span class="o">=</span> <span class="n">vel_des</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_vel_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latest_new_vel</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">latest_new_vel</span> <span class="o">=</span> <span class="n">new_vel_final</span>
        <span class="k">return</span> <span class="n">new_vel_final</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Eric Greuel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>